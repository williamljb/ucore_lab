# lab7 报告

## 练习题
### 练习一 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
---

问题回答：内核级信号量semaphore里面有一个value表示当前剩余资源数以及waitqueue表示等待队列。

一个线程请求资源时使用down函数，调用到__down具体申请资源。如果value大于0，那么可以直接获得并返回。
否则把当前线程加入到等待队列中，让其睡眠，并用schedule调度其他的线程。

一个线程释放资源时使用up函数，调用到__up具体释放资源。如果等待队列为空，那么直接让value自增即可。
否则选择一个等待队列中的线程，唤醒它。

如果要给用户态进程提供信号量。那么由于这两个函数都需要有对调度的调整，那么必须是在内核态中运行的。
所以我们可以新建系统调用sys_sem，sys_up，sys_down，分别用来新建信号量，释放资源和申请资源。
在具体的三个中断处理函数中分别调用内核态的三个函数即可。

---

### 练习二 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
---

实现过程：条件变量中有一个value表示有多少线程在等待，以及waitqueue表示等待队列。管程中首先有一个
mutex表示进入管程的信号量，有一个条件变量数组表示管程里面管理的条件，一个next信号量表示等待使用
管程的线程，以及nextcount表示等待使用管程的线程数。

线程使用cond_signal时，表示此时该条件成立，可以唤醒等待该条件的线程。此时优先让等待条件的线程运行，
故把当前线程放入等待队列，唤醒相应线程，并重新调度。

线程使用cond_wait时，表示此时需要等待条件，那么可以先让出管程的控制权，唤醒等待管程的线程，或者释放
管程的锁，然后等待条件，进入睡眠。醒来之后直接退出，表示此时满足条件，可以继续。

哲学家就餐问题中，申请叉子时，如果发现条件不能满足，那么进入等待，条件为（本人相邻的人都不在吃）。
释放叉子时，首先把自己的状态设置为不在吃，然后试图唤醒相邻的人。如果可以唤醒，那么让它醒来，并让其结束
申请过程。当然在进入之前需要获得管程的互斥锁，退出时需要唤醒等待管程的线程，或者释放互斥锁。

和答案不一样的是，答案中申请叉子是用的是while，而我用的是if。在当前问题中，用if和用while是一样的。

问题回答：同样地，我们可以新建三个系统调用，来分别初始化，等待以及释放条件变量。当然也可以只使用对信号
量处理的系统调用，不过由于管程中频繁使用信号量，这种方法可能会让效率变低。

---

另外，lab7运行时也出现了lab6中出现的输出消息嵌套的问题。后来经过对比和研究发现是lab6的enqueue中
需要把剩余time_slice等于0的也设置为MAX_TIME_SLICE。这样的话会让每次进程执行时都会设置为resched=1。
导致重新调度次数变大，就出现了输出嵌套了。

---


### 重要的知识点
---

理论课中的读者写者问题没有在实验中实现。
实验中对管程的具体实现在原理课中没有讲清楚，读者写者问题也只是简单地用条件变量实现。

---

