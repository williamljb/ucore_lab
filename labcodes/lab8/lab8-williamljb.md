# lab8 报告

## 练习题
### 练习一 完成读文件操作的实现
---

实现过程：我们要从sin这个inode中从offset到endpos这些位置所代表的block进行io操作。首先判断开头是否不满一个block，
是的话就用buf_io的操作；然后中间的每个block用的是blk_io的操作；最后再判断结尾是否不满一个block，是的话也用buf_io
的操作。ret返回是否操作成功，alen返回操作成功长度。

需要注意一下细节。比如整段只在一个block内，中间没有完整的block等等。另外blkno是无符号整型，这个也可能会导致出错。

和答案不一样的是，之前以为ret返回的是操作长度，从而把ret设置成alen返回了。最新的版本中已经修改回来，并在操作过程中
添加好出错的处理。

问题回答：新增系统调用pipe_new，pipe_read，pipe_write来负责管道的新建，读入和输出。管道内维护如下信息：读指针，写
指针，信号量和文件的inode。两个指针重合时为缓冲区空，写指针在读指针前一格时为缓冲区满。然后信号量保证有一个进程在写的
时候其他进程不能操作，并可以让无法读写的时候让进程进入睡眠，在完成读写操作时可以唤醒相应的等待进程。

---

### 练习二 完成基于文件系统的执行程序机制的实现
---

实现过程：仔细分析一下可以知道和lab7的load_icode不一样的是，之前参数直接由一个binary为文件的数据。而这里只有一个文件
的句柄。那么这里我们只需要改一下和文件数据有关系的地方，也就是之前的load_icode中和binary有关的地方，按照它的offset和
需要的东西来从文件读入相应的数据即可。

但是这样不能让sh正常运行。和答案检查校对之后发现是用户态程序的堆栈没有建立好。那么我们可以根据argc和argv，在堆栈的USTACKTOP
开始建立main的参数堆栈（分别为argv的数据，argv的指针，和argc），然后返回新的栈顶位置即可。

运行sh之后发现priority的输出和之前不一样。这个是由于priority本身测试的时候用的是绝对时间，而不是从它这个程序开始运行时
计算的相对时间。修改priority的代码之后可以输出期望得到的结果。

和答案不一样的是，在读入文件的时候，我本来用的是kmalloc和kfree来为指针分配内存。其实这个是不必要的，只要直接新建一个struct
并让想读入的指针指向这个struct即可。另外之前在加载data区的时候需要有一个from的uchar数组来缓存，之后再strcpy。这里也
是不必要的。只要在读入函数那里直接传目的地的指针即可。

问题回答：硬链接的话，直接在新建inode的时候让disk_inode也等于目标的disk_inode即可。删除的时候要麻烦一点，需要查看disk_inode
是否已经没有硬链接了，如果是的话才去删除它。软链接的话可以在in_type处增加一项叫做inode_type_soft_link_info。并
增加一个string表示软链接的目的地址。如果对这种类型的inode进行读写操作的话，需要解析它所指向的目的地址，再次进行地址
解析，并在解析成功之后对目的的inode进行相同的操作。如果解析不成功则返回找不到文件错误。

---

---


### 重要的知识点
---

理论课中的冗余磁盘阵列RAID没有在实验中实现。
实验中对VFS的inode以及SFS的inode没有在原理课中讲清楚它们之间的关系，也没有讲到新的load_icode的实现方法。

---

