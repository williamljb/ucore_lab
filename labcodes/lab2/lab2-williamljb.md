# lab2 报告

## 练习题
### 练习一 实现最先匹配的内存分配机制
---

实现过程：读完default_pmm.c的程序之后，发现它在alloc和free的时候对property位以及块的位置处理有些不符合最先匹配的机制，所以进行了修改。
具体地，在alloc的时候，找到了一个可以容纳的块之后，如果有多余的空间，把它切开之后，应该设置它的property位为1，并把它的link加到原来块的link后面，然后再删去原来的link。
在free的时候，首先要找到它所在的位置。这个就是从链表头开始，找到第一个page地址比它大的（或者在链表尾部），在它前面插入这个link即可。
然后就是合并周围的块。如果前面或者后面有相邻的块，那么可以进行合并：把较后的那块的property位设置为0，删除后面的link，并更新前面那块的大小信息。
注意到合并最多进行两次，所以没有必要遍历一遍链表。

改进：alloc的时候我们需要找到空闲大小比n大的第一块，free的时候需要找到page地址比base大的第一块，这些都可以用线段树来维护，这样操作的复杂度可以降到O(log N)。

答案是对每个页都各自维护了reserved和property，比按块维护要慢，但是潜在出错率低。

---

### 练习二 实现访问二级页表
---

实现过程：按照注释中的提示，首先得到一级页表的对应项，检查其是否有效，如果无效则需要新建页面再返回二级页表项，否则直接返回。
新建页面的时候，需要向管理器申请一个页面，如果不允许申请或者申请失败则返回空指针。然后清空该页，作为这个页目录项指向的二级页表。
得到这个页表的地址之后，在页目录项填入其起始地址和权限位即可。
自己写代码的时候写了很久都不能通过测试，最后不得已看了答案，发现有如下不同：
首先是使用的地址。返回的时候需要将页目录项的数转为内核地址再加，在清空页表的时候也是一样。这里是没有弄清楚KADDR究竟要怎么用，用在哪里。
然后就是返回数，本来写的是二级页表的基地址，后来才发现是要返回页表项。这个属于没有弄清楚这个函数需要做些什么导致的。
然后就是清空页表的时候，大小以为是sizeof(Page)，其实是真正的一页的大小，这个是属于没有搞明白实现的原理。

PDE中有对应的二级页表基地址，以及三个权限位：是否有效、可写、可被用户访问；PTE中有对应页的物理基地址，以及两个权限位：是否有效、可写。
这些权限位用于判断页面是否存在，用来管理内存以及保护数据。

如果出现了页访问异常，硬件需要对硬盘发出信号，在内存和硬盘之间交换数据。

---

### 练习三 实现删除二级页表
---

实现过程：按照注释中的提示，首先判断该二级页表是否有效，无效的话可以直接退出。否则把它所指向的页的引用次数减一，如果到0的话就释放该页。
然后把二级页表项清零，最后刷新一下tlb即可。写完之后和参考答案对比发现有一处不同，即清空二级页表项处，我错误地写成了一级页表项了。这个是没有清楚理解题意。

有对应关系，页表是从end开始的连续一段内存存放的。

令gcc编译出的虚拟起始地址从0x100000开始即可。

---


### 重要的知识点
---

实验中用到的KADDR宏没有在实验课上清楚介绍其用法。
原理课上的和缺页有关的知识点在实验中没有体现。

---

