# lab1 报告

## 练习题
### 练习一 理解通过make生成执行文件的过程。
---

首先用gcc命令把各个c文件编译成.o文件。参数有：-I，-fno-builtin，-Wall，-ggdb，-m32，-gstabs，-nostdinc，-fno-stack-protector，-c，-o。
参数的意义分别为：添加头文件路径，不承认不以__builtin_开头的函数为内建函数，生成所有警告，生成gdb专用的调试信息，进行32位的编译，
以stabs格式生成调试信息，使编译器不在系统缺省的头文档目录里面找头文档，禁用堆栈保护，只编译不链接，指定输出文件。

然后用ld命令把生成的.o文件链接起来。参数有：-m elf_i386，-nostdlib，-T，-o，-N，-e start, -Ttext 0x7c00。
参数的意义分别为：elf格式输出32位的文件，不连接系统标准启动文件和标准库文件，指定自己的链接脚本，
指定输出文件，ldconfig不重建缓存文件，start为入口，以0x7c00地址开始。

最后用dd命令把二进制文件写入到img文件中。参数有：if，of，count，conv=notrunc，seek。
参数的意义分别为：指定输入文件，指定输出文件，处理数据的大小，不截短输出文件，输出文件从头跳过若干块再开始。

符合规范的硬盘主引导扇区，在sign.c可以看到，最后两个字分别为0x55和0xAA。

---

### 练习二 qemu和gdb的使用
---

加电后第一条指令地址在0xfff0，且用x /10i $pc无法看出其汇编代码，加上hook-stop仍然不能知道当前的指令。之后跳到了0xd000和0xf0000这两块区域，
显示出来的汇编代码也与实际执行的不一样（跳转地址不一样），估计可能是qemu本身的一些初始化代码以及BIOS的代码。

设置0x7c00断点后，continue即跳到了该位置。显示出来的汇编代码即是bootasm.s中的代码。后来即跳到了bootmain处。
设置0x7cfe之后，成功跳转到了bootmain处。

---

### 练习三 加载程序
---

开启A20可以让寻址变为32位，可用内存扩大到4G，以便后续的程序使用。开启A20要向8042键盘控制器输入数据，因为A20指示位设置在了那里。
等到8042空闲的时候，向它请求输入数据。得到响应后，向其0x60端口输入0xdf数据，即可打开A20。

GDT表在bootasm.s的最下面即可看到，直接写入三个表项：空，代码段和数据段即可。其中代码段和数据段均使用0到4G的空间。

使能保护模式只要把cr0的第0位置为1即可。进入保护模式需要用一个long jump进入到32位的代码段。

---

### 练习四 ucore内核映像加载
---

读取某个扇区的过程：等待磁盘准备好；输入命令（读取某个扇区）；等待磁盘准备好；读取数据。

加载OS：首先读取第一个扇区的数据，里面有elfhdr的数据，从里面可以找出来程序的开始地址等参数，以及各个程序段的大小和偏移量。
然后再根据这些信息去读取相应的程序段并放到要求的位置即可。

---
### 练习五 函数调用栈分析
---

实现过程：一步步按照注释所提示的来写，在程序中使用了asm volatile来获得函数参数arg和eip，ebp的值。最后输出和标程输出相同。

标程的话是由于ebp的指针单位为4bit，所以参数变成了ebp+2所指向的地址的0到4号元素，eip变成了ebp+1指向的元素。两者是等效的。
最后一行是bootmain的最后一句话（调用kern_init）的语句地址。

---


### 练习六 完善中断初始化和处理
---

1、一个表项为一个终端门描述符，故大小为8个字节。后16位接上前16位共32位的地址表示段偏移。
由于代码段其实地址为0，故这个偏移就是中断处理代码的入口。

2、按照注释，需要做的就是把所有的中断描述符建立起来。我们用SETGATE来建立这个描述符，现在只需要知道每个中断是否为硬中断，
它们的段选择子，它们的例程起始位置，以及特权级。起始位置已经在__vectors[]中存放好了。特权级的话除了系统调用0x80为3之外其他都是0。
段选择子的话，我们看到pmm.c中它刚初始化好的GDT里，第二项为内核代码段，故index为1，然后TI和RPL都是0，所以段选择子为0x8。
是否为硬中断的话，我们看到trap.c中trapname函数里有分开硬中断和其他中断的条件，复制过来即可。

3、只需要在相应位置上让ticks加一，满了TICK_NUM之后调用print_ticks()函数并复位ticks即可。
编译通过后运行效果与标程一样。正解中把所有中断都当成硬中断了，之后用GD_KTEXT来表示段选择子。
此时发现memlayout.h中有关于段选择子的一些信息。以后可以从这里找到想要的选择子了。

---


### CHALLENGE 内核态和用户态之间的切换
---

本来一开始看到提示的时候打算通过中断进入中断处理程序再直接写汇编代码修改CS等寄存器再iret，结果发现怎么弄都会让栈崩掉。
后来看了参考答案和piazza中的一篇帖子，终于理解这个过程的机制。

在trapentry.s中有处理中断的总入口。它在栈中模拟了一个trapframe结构，并用push %esp来实现了一个指针，作为参数调用trapdispatch。
返回之后再把所有的参数弹出回复原状。所以我们只需要修改trapframe结构中的cs和esp等的变量即可实现切换特权级。

但是，这个切换并不是对称的。从内核态切换到用户态，比从用户态切换到内核态，栈中少了cs和esp两个元素。
这个是因为在内核态的时候调用中断并没有发生特权级转换，而在用户态的时候调用中断则出现了特权级转换（中断是在内核处理的）。
这样的话导致了内核态的trapframe不是完整的，它少了cs和esp。所以我们不能直接修改参数中的trapframe，它只是一个被虚拟出来的结构。

从内核态切换到用户态的时候，参数的trapframe不是完整的，而我们返回的时候需要返回一个完整的包含cs和esp的trapframe，从而让iret觉得
这是一个特权级切换，然后正常进入到用户态。由于参数少了cs和esp，我们切换到用户态的时候，新建一个trapframe实例，
它的esp要设置成离trapframe指针相差sizeof(trapframe)-8的位置，才能在返回的时候回到正常的位置。

同理从用户态切换到内核态的时候，参数是一个完整的trapframe，但是我们需要返回一个不完整trapframe的指针。
所以切换到内核态的时候，需要一个trapframe，它的指针头距离压栈前的栈顶为sizeof(trapframe)-8。

所以为了实现的方便，这两种情况分别用了一个实例和一个指针，这个指针设置好之后再把数据搬过去。

值得注意的是，最后一句话的效果非常的神奇。由于在调用trapdispatch之前有一句push %esp，所以输入参数作为地址减去8字节之后，就是自己所在的地址。
然后让这个地址中的数改为我们想要返回的trapframe的指针，在返回之后经过汇编代码的pop %esp即可把esp移过去trapframe中，
让它pop的时候把我们修改过的寄存器的值放进寄存器中，之后再经过一次iret把%esp复原，即可不被察觉地切换特权级。

---
