# lab1 报告

## 练习题
### 练习一 理解通过make生成执行文件的过程。
---

首先用gcc命令把各个c文件编译成.o文件。参数有：-I，-fno-builtin，-Wall，-ggdb，-m32，-gstabs，-nostdinc，-fno-stack-protector，-c，-o。
参数的意义分别为：添加头文件路径，不承认不以__builtin_开头的函数为内建函数，生成所有警告，生成gdb专用的调试信息，进行32位的编译，
以stabs格式生成调试信息，使编译器不在系统缺省的头文档目录里面找头文档，禁用堆栈保护，只编译不链接，指定输出文件。

然后用ld命令把生成的.o文件链接起来。参数有：-m elf_i386，-nostdlib，-T，-o，-N，-e start, -Ttext 0x7c00。
参数的意义分别为：elf格式输出32位的文件，不连接系统标准启动文件和标准库文件，指定自己的链接脚本，
指定输出文件，ldconfig不重建缓存文件，start为入口，以0x7c00地址开始。

最后用dd命令把二进制文件写入到img文件中。参数有：if，of，count，conv=notrunc，seek。
参数的意义分别为：指定输入文件，指定输出文件，处理数据的大小，不截短输出文件，输出文件从头跳过若干块再开始。

符合规范的硬盘主引导扇区，在sign.c可以看到，最后两个字分别为0x55和0xAA。

---

### 练习二 qemu和gdb的使用
---

加电后第一条指令地址在0xfff0，且用x /10i $pc无法看出其汇编代码，加上hook-stop仍然不能知道当前的指令。之后跳到了0xd000和0xf0000这两块区域，
显示出来的汇编代码也与实际执行的不一样（跳转地址不一样），估计可能是qemu本身的一些初始化代码以及BIOS的代码。

设置0x7c00断点后，continue即跳到了该位置。显示出来的汇编代码即是bootasm.s中的代码。后来即跳到了bootmain处。
设置0x7cfe之后，成功跳转到了bootmain处。

---

### 练习三 加载程序
---

开启A20可以让寻址变为32位，可用内存扩大到4G，以便后续的程序使用。开启A20要向8042键盘控制器输入数据，因为A20指示位设置在了那里。
等到8042空闲的时候，向它请求输入数据。得到响应后，向其0x60端口输入0xdf数据，即可打开A20。

GDT表在bootasm.s的最下面即可看到，直接写入三个表项：空，代码段和数据段即可。其中代码段和数据段均使用0到4G的空间。

使能保护模式只要把cr0的第0位置为1即可。进入保护模式需要用一个long jump进入到32位的代码段。

---

### 练习四 ucore内核映像加载
---

读取某个扇区的过程：等待磁盘准备好；输入命令（读取某个扇区）；等待磁盘准备好；读取数据。

加载OS：首先读取第一个扇区的数据，里面有elfhdr的数据，从里面可以找出来程序的开始地址等参数，以及各个程序段的大小和偏移量。
然后再根据这些信息去读取相应的程序段并放到要求的位置即可。

---
### 练习五 函数调用栈分析
---

实现过程：一步步按照注释所提示的来写，在程序中使用了asm volatile来获得函数参数arg和eip，ebp的值。最后输出和标程输出相同。

标程的话是由于ebp的指针单位为4bit，所以参数变成了ebp+2所指向的地址的0到4号元素，eip变成了ebp+1指向的元素。两者是等效的。
最后一行是bootmain的最后一句话（调用kern_init）的语句地址。

---


### 练习六 完善中断初始化和处理
---

1、一个表项为一个终端门描述符，故大小为8个字节。后16位接上前16位共32位的地址表示段偏移。
由于代码段其实地址为0，故这个偏移就是中断处理代码的入口。

2、按照注释，需要做的就是把所有的中断描述符建立起来。我们用SETGATE来建立这个描述符，现在只需要知道每个中断是否为硬中断，
它们的段选择子，它们的例程起始位置，以及特权级。起始位置已经在__vectors[]中存放好了。特权级的话除了系统调用0x80为3之外其他都是0。
段选择子的话，我们看到pmm.c中它刚初始化好的GDT里，第二项为内核代码段，故index为1，然后TI和RPL都是0，所以段选择子为0x8。
是否为硬中断的话，我们看到trap.c中trapname函数里有分开硬中断和其他中断的条件，复制过来即可。

3、只需要在相应位置上让ticks加一，满了TICK_NUM之后调用print_ticks()函数并复位ticks即可。
编译通过后运行效果与标程一样。正解中把所有中断都当成硬中断了，之后用GD_KTEXT来表示段选择子。
此时发现memlayout.h中有关于段选择子的一些信息。以后可以从这里找到想要的选择子了。

---
